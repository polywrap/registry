{
  "language": "Solidity",
  "sources": {
    "contracts/ens/TestENSRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\";\n\ncontract TestENSRegistry is ENSRegistry {}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/**\n * The ENS registry contract.\n */\ncontract ENSRegistry is ENS {\n\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping (bytes32 => Record) records;\n    mapping (address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Constructs a new ENS registrar.\n     */\n    constructor() public {\n        records[0x0].owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets the record for a node.\n     * @param node The node to update.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /**\n     * @dev Sets the record for a subnode.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /**\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /**\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /**\n     * @dev Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * @dev Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /**\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\n     * @param operator Address to add to the set of authorized operators.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     * @param node The specified node.\n     * @return address of the owner.\n     */\n    function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     * @param node The specified node.\n     * @return address of the resolver.\n     */\n    function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * @dev Returns the TTL of a node, and any records associated with it.\n     * @param node The specified node.\n     * @return ttl of the node.\n     */\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * @dev Returns whether a record has been imported to the registry.\n     * @param node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /**\n     * @dev Query if an address is an authorized operator for another address.\n     * @param owner The address that owns the records.\n     * @param operator The address that acts on behalf of the owner.\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\n        if(resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if(ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external virtual;\n    function setOwner(bytes32 node, address owner) external virtual;\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\n    function setApprovalForAll(address operator, bool approved) external virtual;\n    function owner(bytes32 node) external virtual view returns (address);\n    function resolver(bytes32 node) external virtual view returns (address);\n    function ttl(bytes32 node) external virtual view returns (uint64);\n    function recordExists(bytes32 node) external virtual view returns (bool);\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\n}\n"
    },
    "contracts/versioning/domain-registries/links/EnsLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport \"../../../helpers/StringToAddressParser.sol\";\nimport \"../interfaces/IDomainRegistryLink.sol\";\n\ninterface ITextResolverInterface {\n  function setText(\n    bytes32 node,\n    string calldata key,\n    string calldata value\n  ) external;\n\n  function text(bytes32 node, string calldata key)\n    external\n    view\n    returns (string memory);\n}\n\ncontract EnsLink is StringToAddressParser, IDomainRegistryLink {\n  string internal constant POLYWRAP_OWNER_RECORD_NAME = \"polywrap-owner\";\n\n  ENS internal ens;\n\n  constructor(ENS _ens) {\n    ens = _ens;\n  }\n\n  function getPolywrapOwner(bytes32 domainRegistrarNode)\n    public\n    view\n    override\n    returns (address)\n  {\n    address textResolverAddr = ens.resolver(domainRegistrarNode);\n\n    require(textResolverAddr != address(0), \"Resolver not set\");\n\n    ITextResolverInterface ensTextResolver = ITextResolverInterface(\n      textResolverAddr\n    );\n\n    return\n      stringToAddress(\n        ensTextResolver.text(domainRegistrarNode, POLYWRAP_OWNER_RECORD_NAME)\n      );\n  }\n}\n"
    },
    "contracts/helpers/StringToAddressParser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract StringToAddressParser {\n  function stringToAddress(string memory _a)\n    internal\n    pure\n    returns (address _parsedAddress)\n  {\n    bytes memory tmp = bytes(_a);\n    uint160 iaddr = 0;\n    uint160 b1;\n    uint160 b2;\n    for (uint256 i = 2; i < 2 + 2 * 20; i += 2) {\n      iaddr *= 256;\n      b1 = uint160(uint8(tmp[i]));\n      b2 = uint160(uint8(tmp[i + 1]));\n      if ((b1 >= 97) && (b1 <= 102)) {\n        b1 -= 87;\n      } else if ((b1 >= 65) && (b1 <= 70)) {\n        b1 -= 55;\n      } else if ((b1 >= 48) && (b1 <= 57)) {\n        b1 -= 48;\n      }\n      if ((b2 >= 97) && (b2 <= 102)) {\n        b2 -= 87;\n      } else if ((b2 >= 65) && (b2 <= 70)) {\n        b2 -= 55;\n      } else if ((b2 >= 48) && (b2 <= 57)) {\n        b2 -= 48;\n      }\n      iaddr += (b1 * 16 + b2);\n    }\n    return address(iaddr);\n  }\n}\n"
    },
    "contracts/versioning/domain-registries/interfaces/IDomainRegistryLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IDomainRegistryLink {\n  function getPolywrapOwner(bytes32 domainRegistryNode)\n    external\n    view\n    returns (address);\n}\n"
    },
    "contracts/versioning/domain-registries/links/TestLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IDomainRegistryLink.sol\";\n\ncontract TestLink is IDomainRegistryLink {\n  string internal constant POLYWRAP_OWNER_RECORD_NAME = \"polywrap-owner\";\n\n  function getPolywrapOwner(bytes32 domainRegistryNode)\n    public\n    view\n    override\n    returns (address)\n  {\n    //Using the transaction origin the caller account will be the owner\n    //This allows us to not need a \"Test\" domain registry to test custom link contracts\n    return tx.origin;\n  }\n}\n"
    },
    "contracts/versioning/PackageOwnershipManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./registry/Registry.sol\";\nimport \"./bridges/interfaces/IOwnershipBridgeLink.sol\";\nimport \"./domain-registries/interfaces/IDomainRegistryLink.sol\";\n\ncontract PackageOwnershipManager is OwnableUpgradeable {\n  address public registry;\n\n  mapping(bytes32 => address) public domainRegistryLinks;\n\n  mapping(bytes32 => bool) public allowedLocalDomainRegistries;\n  mapping(bytes32 => address) public incomingBridgeLinks;\n  mapping(bytes32 => address) public outgoingBridgeLinks;\n\n  constructor(\n    address _registry,\n    bytes32[] memory _domainRegistries,\n    address[] memory _domainRegistryLinks\n  ) {\n    initialize(_registry, _domainRegistries, _domainRegistryLinks);\n  }\n\n  function initialize(\n    address _registry,\n    bytes32[] memory _domainRegistries,\n    address[] memory _domainRegistryLinks\n  ) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n\n    require(\n      _domainRegistries.length == _domainRegistryLinks.length,\n      \"Registry arrays must have the same length\"\n    );\n\n    for (uint256 i = 0; i < _domainRegistries.length; i++) {\n      domainRegistryLinks[_domainRegistries[i]] = _domainRegistryLinks[i];\n    }\n  }\n\n  function updateRegistry(address _registry) public {\n    registry = _registry;\n  }\n\n  function updateLocalDomainRegistryPermission(\n    bytes32 domainRegistry,\n    bool allowed\n  ) public onlyOwner {\n    allowedLocalDomainRegistries[domainRegistry] = allowed;\n  }\n\n  function updateIncomingBridgeLink(\n    bytes32 domainRegistry,\n    bytes32 blockchainName,\n    address bridgeLink\n  ) public onlyOwner {\n    bytes32 key = keccak256(abi.encodePacked(domainRegistry, blockchainName));\n\n    incomingBridgeLinks[key] = bridgeLink;\n  }\n\n  function updateOutgoingBridgeLink(\n    bytes32 domainRegistry,\n    bytes32 blockchainName,\n    address bridgeLink\n  ) public onlyOwner {\n    bytes32 key = keccak256(abi.encodePacked(domainRegistry, blockchainName));\n\n    outgoingBridgeLinks[key] = bridgeLink;\n  }\n\n  function connectDomainRegistryLink(\n    bytes32 domainRegistry,\n    address _domainRegistryLink\n  ) public onlyOwner {\n    domainRegistryLinks[domainRegistry] = _domainRegistryLink;\n  }\n\n  function updateOwnership(bytes32 domainRegistry, bytes32 domainRegistryNode)\n    public\n  {\n    require(\n      allowedLocalDomainRegistries[domainRegistry],\n      \"Domain registry is not allowed for local updates\"\n    );\n\n    address owner = getPolywrapOwner(domainRegistry, domainRegistryNode);\n\n    Registry(registry).updateOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function relayOwnership(\n    bytes32 blockchainName,\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode\n  ) public {\n    address bridgeLink = outgoingBridgeLinks[\n      keccak256(abi.encodePacked(domainRegistry, blockchainName))\n    ];\n\n    require(\n      bridgeLink != address(0),\n      \"Outgoing relay not supported for domain registry and blockchain\"\n    );\n\n    address owner = getPolywrapOwner(domainRegistry, domainRegistryNode);\n\n    IOwnershipBridgeLink(bridgeLink).relayOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 blockchainName,\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode,\n    address owner\n  ) public {\n    address bridgeLink = incomingBridgeLinks[\n      keccak256(abi.encodePacked(domainRegistry, blockchainName))\n    ];\n\n    require(\n      bridgeLink != address(0),\n      \"Incoming relay not supported for domain registry and blockchain\"\n    );\n\n    assert(msg.sender == bridgeLink);\n\n    Registry(registry).updateOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function getPolywrapOwner(bytes32 domainRegistry, bytes32 domainRegistryNode)\n    public\n    view\n    returns (address)\n  {\n    address domainRegistryLinkAddress = domainRegistryLinks[domainRegistry];\n\n    require(\n      domainRegistryLinkAddress != address(0),\n      \"Domain registry is not supported\"\n    );\n\n    return\n      IDomainRegistryLink(domainRegistryLinkAddress).getPolywrapOwner(\n        domainRegistryNode\n      );\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/versioning/registry/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract Registry is OwnableUpgradeable {\n  event OwnershipUpdated(\n    bytes32 indexed domainRegistryNode,\n    bytes32 packageId,\n    bytes32 domainRegistry,\n    address indexed owner\n  );\n\n  event VersionPublished(\n    bytes32 indexed packageId,\n    uint256 major,\n    uint256 minor,\n    uint256 patch,\n    string location\n  );\n\n  struct PackageVersion {\n    bool leaf;\n    uint256 latestSubVersion;\n    bool created;\n    string location; // empty on non-leaf nodes\n  }\n\n  struct PackageInfo {\n    address owner;\n    bytes32 domainRegistryNode;\n    bytes32 domainRegistry;\n  }\n\n  mapping(bytes32 => PackageVersion) public versionNodes;\n  mapping(bytes32 => PackageInfo) public packages;\n  address public ownershipUpdater;\n  address public versionPublisher;\n\n  constructor() {\n    initialize();\n  }\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function updateOwnershipUpdater(address _ownershipUpdater) public onlyOwner {\n    ownershipUpdater = _ownershipUpdater;\n  }\n\n  function updateVersionPublisher(address _versionPublisher) public onlyOwner {\n    versionPublisher = _versionPublisher;\n  }\n\n  function updateOwnership(\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode,\n    address domainOwner\n  ) public {\n    assert(msg.sender == ownershipUpdater);\n\n    bytes32 packageId = keccak256(\n      abi.encodePacked(\n        keccak256(abi.encodePacked(domainRegistryNode)),\n        domainRegistry\n      )\n    );\n\n    packages[packageId] = PackageInfo(\n      domainOwner,\n      domainRegistryNode,\n      domainRegistry\n    );\n\n    emit OwnershipUpdated(\n      domainRegistryNode,\n      packageId,\n      domainRegistry,\n      domainOwner\n    );\n  }\n\n  function publishVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string memory location\n  ) public returns (bytes32) {\n    assert(msg.sender == versionPublisher);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    PackageVersion storage packageNode = versionNodes[packageId];\n    PackageVersion storage majorNode = versionNodes[majorNodeId];\n    PackageVersion storage minorNode = versionNodes[minorNodeId];\n\n    if (packageNode.latestSubVersion < majorVersion) {\n      packageNode.latestSubVersion = majorVersion;\n    }\n    packageNode.created = true;\n\n    if (majorNode.latestSubVersion < minorVersion) {\n      majorNode.latestSubVersion = minorVersion;\n    }\n    majorNode.created = true;\n\n    if (minorNode.latestSubVersion < patchVersion) {\n      minorNode.latestSubVersion = patchVersion;\n    }\n    minorNode.created = true;\n\n    require(!versionNodes[patchNodeId].created, \"Version is already published\");\n\n    versionNodes[patchNodeId] = PackageVersion(true, 0, true, location);\n\n    emit VersionPublished(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n\n    return patchNodeId;\n  }\n\n  function getPackageOwner(bytes32 packageId) public view returns (address) {\n    return packages[packageId].owner;\n  }\n}\n"
    },
    "contracts/versioning/bridges/interfaces/IOwnershipBridgeLink.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface IOwnershipBridgeLink {\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) external;\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/VerificationRootBridgeLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../VersionVerificationManager.sol\";\nimport \"../../PackageOwnershipManager.sol\";\nimport \"./ITokenBridge.sol\";\nimport \"../interfaces/IVerificationRootBridgeLink.sol\";\n\ncontract VerificationRootBridgeLink is\n  IVerificationRootBridgeLink,\n  OwnableUpgradeable\n{\n  address public bridge;\n  address public bridgeLink;\n  address public verificationRootRelayer;\n  address public versionVerificationManager;\n  bytes32 public bridgeChainId;\n  uint256 public relayVerificationRootGasLimit;\n\n  constructor(\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  ) {\n    initialize(_bridge, _bridgeChainId, _relayVerificationRootGasLimit);\n  }\n\n  function initialize(\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  ) public initializer {\n    __Ownable_init();\n\n    bridge = _bridge;\n    bridgeChainId = _bridgeChainId;\n    relayVerificationRootGasLimit = _relayVerificationRootGasLimit;\n  }\n\n  function updateBridge(address _bridge) public onlyOwner {\n    bridge = _bridge;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updateVerificationRootRelayer(address _verificationRootRelayer)\n    public\n    onlyOwner\n  {\n    verificationRootRelayer = _verificationRootRelayer;\n  }\n\n  function updateVersionVerificationManager(address _versionVerificationManager)\n    public\n    onlyOwner\n  {\n    versionVerificationManager = _versionVerificationManager;\n  }\n\n  function updateBridgeChainId(bytes32 _bridgeChainId) public onlyOwner {\n    bridgeChainId = _bridgeChainId;\n  }\n\n  function updateRelayVerificationRootGasLimit(\n    uint256 _relayVerificationRootGasLimit\n  ) public onlyOwner {\n    relayVerificationRootGasLimit = _relayVerificationRootGasLimit;\n  }\n\n  function relayVerificationRoot(bytes32 verificationRoot)\n    public\n    virtual\n    override\n  {\n    assert(msg.sender == verificationRootRelayer);\n\n    bytes4 methodSelector = IVerificationRootBridgeLink(address(0))\n      .receiveVerificationRoot\n      .selector;\n    bytes memory data = abi.encodeWithSelector(\n      methodSelector,\n      verificationRoot\n    );\n    ITokenBridge(bridge).requireToPassMessage(\n      bridgeLink,\n      data,\n      relayVerificationRootGasLimit\n    );\n  }\n\n  function receiveVerificationRoot(bytes32 verificationRoot)\n    public\n    virtual\n    override\n  {\n    assert(msg.sender == bridge);\n\n    ITokenBridge bridgeContract = ITokenBridge(bridge);\n    require(bridgeContract.messageSender() == bridgeLink);\n    require(bridgeContract.messageSourceChainId() == bridgeChainId);\n\n    VersionVerificationManager(versionVerificationManager)\n      .updateVerificationRoot(verificationRoot);\n  }\n}\n"
    },
    "contracts/versioning/VersionVerificationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./registry/Registry.sol\";\n\ncontract VersionVerificationManager is OwnableUpgradeable {\n  event VersionPublished(\n    bytes32 indexed packageId,\n    bytes32 indexed verifiedVersionId,\n    bytes32 indexed patchNodeId,\n    uint256 major,\n    uint256 minor,\n    uint256 patch,\n    string location\n  );\n\n  address public registry;\n  address public verificationRootUpdater;\n\n  bytes32 public verificationRoot;\n\n  constructor(address _registry) {\n    initialize(_registry);\n  }\n\n  function initialize(address _registry) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVerificationRootUpdater(address _verificationRootUpdater)\n    public\n    onlyOwner\n  {\n    verificationRootUpdater = _verificationRootUpdater;\n  }\n\n  function updateVerificationRoot(bytes32 root) public {\n    assert(msg.sender == verificationRootUpdater);\n\n    verificationRoot = root;\n  }\n\n  function publishVersion(\n    bytes32 packageId,\n    bytes32 patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string memory location,\n    bytes32[] memory proof,\n    bool[] memory sides\n  ) public packageOwner(packageId) {\n    bytes32 verifiedVersionId = keccak256(\n      abi.encodePacked(patchNodeId, keccak256(abi.encodePacked(location)))\n    );\n\n    require(\n      proveVerifiedVersion(proof, sides, verifiedVersionId, verificationRoot),\n      \"Invalid proof\"\n    );\n\n    bytes32 actualPatchNodeId = Registry(registry).publishVersion(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n\n    require(\n      patchNodeId == actualPatchNodeId,\n      \"Supplied patchNodeId does not match the calculated patchNodeId\"\n    );\n\n    emit VersionPublished(\n      packageId,\n      verifiedVersionId,\n      patchNodeId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n  }\n\n  function proveVerifiedVersion(\n    bytes32[] memory proof,\n    bool[] memory sides,\n    bytes32 verifiedVersionId,\n    bytes32 root\n  ) private pure returns (bool) {\n    bytes32 hash = verifiedVersionId;\n\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n\n      if (sides[i]) {\n        hash = keccak256(abi.encodePacked(proofElement, hash));\n      } else {\n        hash = keccak256(abi.encodePacked(hash, proofElement));\n      }\n    }\n\n    return hash == root;\n  }\n\n  modifier packageOwner(bytes32 packageId) {\n    require(\n      getPackageOwner(packageId) == msg.sender,\n      \"You do not have access to the domain of this package\"\n    );\n    _;\n  }\n\n  function getPackageOwner(bytes32 packageId) private view returns (address) {\n    return Registry(registry).getPackageOwner(packageId);\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/ITokenBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ITokenBridge {\n  function requireToPassMessage(\n    address _contract,\n    bytes calldata _data,\n    uint256 _gas\n  ) external returns (bytes32);\n\n  function messageSender() external view returns (address);\n\n  function messageSourceChainId() external view returns (bytes32);\n}\n"
    },
    "contracts/versioning/bridges/interfaces/IVerificationRootBridgeLink.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface IVerificationRootBridgeLink {\n  function relayVerificationRoot(bytes32 verificationRoot) external;\n\n  function receiveVerificationRoot(bytes32 verificationRoot) external;\n}\n"
    },
    "contracts/versioning/VerificationRootRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./bridges/interfaces/IVerificationRootBridgeLink.sol\";\nimport \"./VerificationTreeManager.sol\";\nimport \"./VersionVerificationManager.sol\";\n\ncontract VerificationRootRelayer is OwnableUpgradeable {\n  address public versionVerificationManager;\n  address public bridgeLink;\n  address public verificationTreeManager;\n  uint256 public blocksPerRootRelay;\n\n  uint256 public lastRootRelayBlock;\n\n  constructor(address _versionVerificationManager, uint256 _blocksPerRootRelay)\n  {\n    initialize(_versionVerificationManager, _blocksPerRootRelay);\n  }\n\n  function initialize(\n    address _versionVerificationManager,\n    uint256 _blocksPerRootRelay\n  ) public initializer {\n    __Ownable_init();\n\n    versionVerificationManager = _versionVerificationManager;\n    blocksPerRootRelay = _blocksPerRootRelay;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updateVersionVerificationManager(address _versionVerificationManager)\n    public\n    onlyOwner\n  {\n    versionVerificationManager = _versionVerificationManager;\n  }\n\n  function updateVerificationTreeManager(address _verificationTreeManager)\n    public\n    onlyOwner\n  {\n    verificationTreeManager = _verificationTreeManager;\n  }\n\n  function updateBlocksPerRootRelay(uint256 _blocksPerRootRelay)\n    public\n    onlyOwner\n  {\n    blocksPerRootRelay = _blocksPerRootRelay;\n  }\n\n  function onVersionVerified() public {\n    assert(msg.sender == verificationTreeManager);\n\n    bytes32 verificationRoot = VerificationTreeManager(verificationTreeManager)\n      .calculateVerificationRoot();\n\n    updateVerificationRoot(verificationRoot);\n\n    if (block.number < lastRootRelayBlock + blocksPerRootRelay) {\n      return;\n    }\n\n    relayVerificationRoot();\n  }\n\n  function relayVerificationRoot() public {\n    assert(versionVerificationManager != address(0));\n\n    if (bridgeLink == address(0)) {\n      return;\n    }\n\n    bytes32 verificationRoot = VersionVerificationManager(\n      versionVerificationManager\n    ).verificationRoot();\n\n    IVerificationRootBridgeLink(bridgeLink).relayVerificationRoot(\n      verificationRoot\n    );\n  }\n\n  function updateVerificationRoot(bytes32 verificationRoot) private {\n    if (versionVerificationManager != address(0)) {\n      VersionVerificationManager(versionVerificationManager)\n        .updateVerificationRoot(verificationRoot);\n    }\n  }\n}\n"
    },
    "contracts/versioning/VerificationTreeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./version-events-listeners/IVersionVerifiedListener.sol\";\nimport \"./VerificationRootRelayer.sol\";\n\ncontract VerificationTreeManager is\n  IVersionVerifiedListener,\n  OwnableUpgradeable\n{\n  event VerificationRootCalculated(\n    bytes32 indexed verificationRoot,\n    uint256 verifiedVersionCount\n  );\n\n  event VersionVerified(\n    bytes32 indexed patchNodeId,\n    bytes32 packageLocationHash,\n    uint256 verifiedVersionIndex\n  );\n\n  struct DynamicMerkleTree {\n    //Track unpaired leaves and the highest level(root is at the top) to calculate the merkle root on the fly\n    uint256 highestTreeLevel;\n    mapping(uint256 => bytes32) unpairedTreeLeaves;\n  }\n\n  DynamicMerkleTree private verificationTree;\n\n  address public registry;\n  address public votingMachine;\n  address public verificationRootRelayer;\n\n  uint256 public verifiedVersionCount;\n\n  constructor(address _registry, address _votingMachine) {\n    initialize(_registry, _votingMachine);\n  }\n\n  function initialize(address _registry, address _votingMachine)\n    public\n    initializer\n  {\n    __Ownable_init();\n\n    registry = _registry;\n    votingMachine = _votingMachine;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVotingMachine(address _votingMachine) public onlyOwner {\n    votingMachine = _votingMachine;\n  }\n\n  function updateVerificationRootRelayer(address _verificationRootRelayer)\n    public\n    onlyOwner\n  {\n    verificationRootRelayer = _verificationRootRelayer;\n  }\n\n  function onVersionVerified(bytes32 patchNodeId, bytes32 packageLocationHash)\n    public\n    override\n  {\n    assert(msg.sender == votingMachine);\n\n    addVersionToTree(patchNodeId, packageLocationHash);\n\n    emit VersionVerified(\n      patchNodeId,\n      packageLocationHash,\n      verifiedVersionCount\n    );\n\n    verifiedVersionCount++;\n\n    VerificationRootRelayer(verificationRootRelayer).onVersionVerified();\n  }\n\n  function addVersionToTree(bytes32 patchNodeId, bytes32 packageLocationHash)\n    private\n  {\n    bytes32 leaf = keccak256(\n      abi.encodePacked(patchNodeId, packageLocationHash)\n    );\n\n    //Go through the unpaired tree leaves and pair them with the new leaf\n    uint256 currentTreeLevel = 0;\n    while (verificationTree.unpairedTreeLeaves[currentTreeLevel] != 0x0) {\n      leaf = keccak256(\n        abi.encodePacked(\n          verificationTree.unpairedTreeLeaves[currentTreeLevel],\n          leaf\n        )\n      );\n\n      verificationTree.unpairedTreeLeaves[currentTreeLevel] = 0x0;\n      currentTreeLevel++;\n    }\n\n    //Store the unpaired leaf to be paired later\n    verificationTree.unpairedTreeLeaves[currentTreeLevel] = leaf;\n\n    //Track the highest level\n    if (currentTreeLevel > verificationTree.highestTreeLevel) {\n      verificationTree.highestTreeLevel = currentTreeLevel;\n    }\n  }\n\n  function calculateVerificationRoot() public returns (bytes32) {\n    assert(msg.sender == verificationRootRelayer);\n\n    bytes32 leaf = 0x0;\n\n    //Go through the unpaired tree leaves and pair them with the \"0x0\" leaf\n    //If there is no unpaired leaf, just propagate the current one upwards\n    uint256 currentTreeLevel = 0;\n    while (currentTreeLevel <= verificationTree.highestTreeLevel) {\n      if (verificationTree.unpairedTreeLeaves[currentTreeLevel] != 0x0) {\n        if (leaf == 0x0) {\n          leaf = verificationTree.unpairedTreeLeaves[currentTreeLevel];\n        } else {\n          leaf = keccak256(\n            abi.encodePacked(\n              verificationTree.unpairedTreeLeaves[currentTreeLevel],\n              leaf\n            )\n          );\n        }\n      }\n\n      currentTreeLevel++;\n    }\n\n    emit VerificationRootCalculated(leaf, verifiedVersionCount);\n\n    return leaf;\n  }\n}\n"
    },
    "contracts/versioning/version-events-listeners/IVersionVerifiedListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVersionVerifiedListener {\n  function onVersionVerified(bytes32 patchNodeId, bytes32 packageLocationHash)\n    external;\n}\n"
    },
    "contracts/versioning/registry/VersionResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registry.sol\";\n\nabstract contract VersionResolver is Registry {\n  function resolveToLeaf(bytes32 versionNodeId) public view returns (bytes32) {\n    PackageVersion storage versionNode = versionNodes[versionNodeId];\n    require(versionNode.created, \"Invalid Node\");\n\n    if (versionNode.leaf) {\n      return versionNodeId;\n    }\n\n    bytes32 latestNodeId = keccak256(\n      abi.encodePacked(versionNodeId, versionNode.latestSubVersion)\n    );\n\n    return resolveToLeaf(latestNodeId);\n  }\n\n  function getPackageLocation(bytes32 versionNodeId)\n    public\n    view\n    returns (string memory)\n  {\n    bytes32 concreteVersionId = resolveToLeaf(versionNodeId);\n    return versionNodes[concreteVersionId].location;\n  }\n}\n"
    },
    "contracts/versioning/registry/PolywrapRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./VersionResolver.sol\";\n\ncontract PolywrapRegistry is VersionResolver {}\n"
    },
    "contracts/versioning/registrar/Registrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../registry/VersionResolver.sol\";\nimport \"../registry/Registry.sol\";\nimport \"../VotingMachine.sol\";\n\nabstract contract Registrar is OwnableUpgradeable {\n  event ManagerAdded(bytes32 indexed packageId, address indexed manager);\n  event ManagerRemoved(bytes32 indexed packageId, address indexed manager);\n\n  address public registry;\n  address public votingMachine;\n\n  mapping(bytes32 => bool) public managers;\n\n  constructor(address _registry) {\n    initialize(_registry);\n  }\n\n  function initialize(address _registry) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVotingMachine(address _votingMachine) public onlyOwner {\n    votingMachine = _votingMachine;\n  }\n\n  function addManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = true;\n\n    emit ManagerAdded(packageId, manager);\n  }\n\n  function removeManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = false;\n\n    emit ManagerRemoved(packageId, manager);\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation\n  ) public {\n    VotingMachine votingMachineContract = VotingMachine(votingMachine);\n\n    votingMachineContract.proposeVersion(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      msg.sender\n    );\n  }\n\n  function isAuthorized(bytes32 packageId, address ownerOrManager)\n    public\n    view\n    returns (bool)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, ownerOrManager));\n\n    if (managers[key]) {\n      return true;\n    }\n\n    return getPackageOwner(packageId) == ownerOrManager;\n  }\n\n  modifier authorized(bytes32 packageId) {\n    require(\n      isAuthorized(packageId, msg.sender),\n      \"You do not have access to this package\"\n    );\n    _;\n  }\n\n  modifier packageOwner(bytes32 packageId) {\n    require(\n      getPackageOwner(packageId) == msg.sender,\n      \"You do not have access to the domain of this package\"\n    );\n    _;\n  }\n\n  function getPackageOwner(bytes32 packageId) private view returns (address) {\n    return Registry(registry).getPackageOwner(packageId);\n  }\n}\n"
    },
    "contracts/versioning/VotingMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./version-events-listeners/IVersionVerifiedListener.sol\";\n\ncontract VotingMachine is OwnableUpgradeable {\n  event VersionProposed(\n    bytes32 indexed packageId,\n    bytes32 patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer\n  );\n\n  event VersionVotingStarted(\n    bytes32 indexed packageId,\n    bytes32 indexed patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer,\n    bool isPatch\n  );\n\n  event VersionVote(\n    address indexed verifier,\n    bytes32 indexed patchNodeId,\n    bytes32 packageLocationHash,\n    bool approved\n  );\n\n  event VersionDecided(\n    bytes32 indexed patchNodeId,\n    bool indexed verified,\n    bytes32 packageLocationHash\n  );\n\n  struct ProposedVersion {\n    address[] approvingVerifiers;\n    address[] rejectingVerifiers;\n    mapping(address => bool) votedVerifiers;\n    bool decided;\n    bool verified;\n    bool votingStarted;\n    bytes32 packageId;\n    bytes32 majorNodeId;\n    bytes32 minorNodeId;\n    bytes32 patchNodeId;\n    string packageLocation;\n    uint256 majorVersion;\n    uint256 minorVersion;\n    uint256 patchVersion;\n    address proposer;\n  }\n\n  struct QueuedVersion {\n    bytes32 nextQueuedVersionId;\n    bytes32 patchNodeId;\n  }\n\n  struct MajorVersionQueueContainer {\n    bytes32 headVersionId;\n    bytes32 tailVersionId;\n    mapping(bytes32 => QueuedVersion) queuedVersions;\n  }\n\n  struct VerifiedMajorVersion {\n    bytes32 lowestMinorNodeId;\n  }\n\n  struct VerifiedMinorVersion {\n    uint256 versionNumber;\n    bytes32 nextMinorNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 majorNodeId;\n    bytes32 patchNodeId;\n  }\n\n  struct Vote {\n    bytes32 patchNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 nextMinorNodeId;\n    bool approved;\n  }\n\n  address public registrar;\n  address public versionVerifiedListener;\n\n  mapping(bytes32 => MajorVersionQueueContainer)\n    public majorVersionQueueContainers;\n  mapping(bytes32 => ProposedVersion) public proposedVersions;\n  mapping(bytes32 => VerifiedMinorVersion) public verifiedMinorVersions;\n  mapping(bytes32 => VerifiedMajorVersion) public verifiedMajorVersions;\n\n  mapping(address => bool) public authorizedVerifiers;\n  uint256 public authorizedVerifierCount;\n\n  constructor(address _registrar) {\n    initialize(_registrar);\n  }\n\n  function initialize(address _registrar) public initializer {\n    __Ownable_init();\n\n    registrar = _registrar;\n  }\n\n  function updateRegistrar(address _registrar) public onlyOwner {\n    registrar = _registrar;\n  }\n\n  function updateVersionVerifiedListener(address _versionVerifiedListener)\n    public\n    onlyOwner\n  {\n    versionVerifiedListener = _versionVerifiedListener;\n  }\n\n  function authorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (!authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = true;\n        authorizedVerifierCount++;\n      }\n    }\n  }\n\n  function unauthorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = false;\n        authorizedVerifierCount--;\n      }\n    }\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation,\n    address proposer\n  ) public {\n    assert(msg.sender == registrar);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    ProposedVersion storage proposedVersion = proposedVersions[patchNodeId];\n\n    require(proposedVersion.patchNodeId == 0x0, \"Version is already proposed\");\n\n    proposedVersion.packageId = packageId;\n\n    proposedVersion.majorNodeId = majorNodeId;\n    proposedVersion.minorNodeId = minorNodeId;\n    proposedVersion.patchNodeId = patchNodeId;\n\n    proposedVersion.majorVersion = majorVersion;\n    proposedVersion.minorVersion = minorVersion;\n    proposedVersion.patchVersion = patchVersion;\n\n    proposedVersion.packageLocation = packageLocation;\n    proposedVersion.proposer = proposer;\n\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    QueuedVersion storage queuedVersion = majorVersionContainer.queuedVersions[\n      patchNodeId\n    ];\n\n    queuedVersion.patchNodeId = patchNodeId;\n\n    if (majorVersionContainer.tailVersionId != 0x0) {\n      //The queue is not empty\n      QueuedVersion storage tailVersion = majorVersionContainer.queuedVersions[\n        majorVersionContainer.tailVersionId\n      ];\n\n      tailVersion.nextQueuedVersionId = patchNodeId;\n      majorVersionContainer.tailVersionId = patchNodeId;\n    } else {\n      //The queue is empty\n      majorVersionContainer.tailVersionId = patchNodeId;\n      majorVersionContainer.headVersionId = patchNodeId;\n\n      //Since there is only one version in the queue, we can start voting for it\n      startVersionVoting(proposedVersion);\n    }\n\n    emit VersionProposed(\n      packageId,\n      patchNodeId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      proposer\n    );\n  }\n\n  function vote(Vote[] memory votes) public {\n    require(\n      authorizedVerifiers[msg.sender],\n      \"You are not an authorized verifier\"\n    );\n\n    for (uint256 i = 0; i < votes.length; i++) {\n      Vote memory vote = votes[i];\n\n      ProposedVersion storage proposedVersion = proposedVersions[\n        vote.patchNodeId\n      ];\n\n      requireCanVoteOnVersion(proposedVersion);\n\n      requireValidMinorVersionPlacement(\n        vote.prevMinorNodeId,\n        vote.nextMinorNodeId,\n        proposedVersion.minorVersion,\n        proposedVersion.majorNodeId,\n        proposedVersion.minorNodeId\n      );\n\n      proposedVersion.votedVerifiers[msg.sender] = true;\n\n      if (vote.approved) {\n        proposedVersion.approvingVerifiers.push(msg.sender);\n      } else {\n        proposedVersion.rejectingVerifiers.push(msg.sender);\n      }\n\n      if (\n        proposedVersion.approvingVerifiers.length > authorizedVerifierCount / 2\n      ) {\n        //The version is verified\n        proposedVersion.decided = true;\n        proposedVersion.verified = true;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      } else {\n        //The version is rejected\n        proposedVersion.decided = true;\n        proposedVersion.verified = false;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      }\n\n      emit VersionVote(\n        msg.sender,\n        proposedVersion.patchNodeId,\n        keccak256(abi.encodePacked(proposedVersion.packageLocation)),\n        vote.approved\n      );\n    }\n  }\n\n  function requireCanVoteOnVersion(ProposedVersion storage proposedVersion)\n    private\n    view\n  {\n    require(proposedVersion.votingStarted, \"Voting has not started\");\n    require(!proposedVersion.decided, \"Voting for this version has ended\");\n    require(!proposedVersion.votedVerifiers[msg.sender], \"You already voted\");\n  }\n\n  function requireValidMinorVersionPlacement(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId\n  ) private view {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    if (currentVersion.patchNodeId != 0x0) {\n      //Minor version has at least one patch version verified and there's no need to keep track of multiple patch versions\n      return;\n    }\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Verify the current version is between prev and next version\n    if (prevVersion.patchNodeId != 0x0) {\n      require(\n        prevVersion.versionNumber < minorVersionNumber,\n        \"Previous version number is not less than the current one\"\n      );\n      require(\n        prevVersion.nextMinorNodeId == nextMinorNodeId,\n        \"Previous version does not point to the next version\"\n      );\n      require(\n        prevVersion.majorNodeId == majorNodeId,\n        \"Previous version does not belong to the same major version\"\n      );\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      require(\n        minorVersionNumber < nextVersion.versionNumber,\n        \"Next version number is not greater than the current one\"\n      );\n      require(\n        nextVersion.prevMinorNodeId == prevMinorNodeId,\n        \"Next version does not point to the previous version\"\n      );\n      require(\n        nextVersion.majorNodeId == majorNodeId,\n        \"Next version does not belong to the same major version\"\n      );\n    }\n  }\n\n  function startVersionVoting(ProposedVersion storage proposedVersion) private {\n    proposedVersion.votingStarted = true;\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      proposedVersion.minorNodeId\n    ];\n\n    emit VersionVotingStarted(\n      proposedVersion.packageId,\n      proposedVersion.patchNodeId,\n      proposedVersion.majorVersion,\n      proposedVersion.minorVersion,\n      proposedVersion.patchVersion,\n      proposedVersion.packageLocation,\n      proposedVersion.proposer,\n      minorVersion.patchNodeId != 0x0\n    );\n  }\n\n  function addToVersionTree(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId\n  ) private {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    currentVersion.patchNodeId = patchNodeId;\n    currentVersion.versionNumber = minorVersionNumber;\n    currentVersion.majorNodeId = majorNodeId;\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Insert into the linked list between prev and next version\n\n    if (prevVersion.patchNodeId != 0x0) {\n      currentVersion.prevMinorNodeId = prevMinorNodeId;\n      prevVersion.nextMinorNodeId = minorNodeId;\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      currentVersion.nextMinorNodeId = nextMinorNodeId;\n      nextVersion.prevMinorNodeId = minorNodeId;\n    }\n\n    if (prevVersion.patchNodeId == 0x0 && nextVersion.patchNodeId == 0x0) {}\n  }\n\n  function onVersionDecided(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId,\n    bool verified,\n    string memory packageLocation\n  ) private {\n    bytes32 packageLocationHash = keccak256(abi.encodePacked(packageLocation));\n\n    if (verified) {\n      addToVersionTree(\n        prevMinorNodeId,\n        nextMinorNodeId,\n        minorVersionNumber,\n        majorNodeId,\n        minorNodeId,\n        patchNodeId\n      );\n\n      if (versionVerifiedListener != address(0)) {\n        IVersionVerifiedListener listener = IVersionVerifiedListener(\n          versionVerifiedListener\n        );\n\n        listener.onVersionVerified(patchNodeId, packageLocationHash);\n      }\n    }\n\n    dequeueNextVersion(majorNodeId);\n\n    emit VersionDecided(patchNodeId, verified, packageLocationHash);\n  }\n\n  function dequeueNextVersion(bytes32 majorNodeId) private {\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    if (majorVersionContainer.headVersionId == 0x0) {\n      //The queue is empty\n      return;\n    }\n\n    QueuedVersion storage headVersion = majorVersionContainer.queuedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    ProposedVersion storage nextVotingVersion = proposedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    if (headVersion.nextQueuedVersionId == 0x0) {\n      majorVersionContainer.headVersionId = 0x0;\n      majorVersionContainer.tailVersionId = 0x0;\n    } else {\n      majorVersionContainer.headVersionId = headVersion.nextQueuedVersionId;\n    }\n\n    startVersionVoting(nextVotingVersion);\n  }\n\n  function getPrevPatchPackageLocation(bytes32 patchNodeId)\n    external\n    view\n    returns (string memory prevPackageLocation)\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      targetVersion.minorNodeId\n    ];\n\n    assert(minorVersion.patchNodeId != 0x0);\n\n    string memory prevPackageLocation = proposedVersions[\n      minorVersion.patchNodeId\n    ].packageLocation;\n\n    return prevPackageLocation;\n  }\n\n  function getPrevAndNextMinorPackageLocations(bytes32 patchNodeId)\n    external\n    view\n    returns (\n      bytes32 prevMinorNodeId,\n      string memory prevPackageLocation,\n      bytes32 nextMinorNodeId,\n      string memory nextPackageLocation\n    )\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMajorVersion memory currentMajorVersion = verifiedMajorVersions[\n      targetVersion.majorNodeId\n    ];\n\n    bytes32 currentMinorNodeId = currentMajorVersion.lowestMinorNodeId;\n    bytes32 nextMinorNodeId = currentMinorNodeId;\n    bytes32 prevMinorNodeId;\n\n    VerifiedMinorVersion memory nextVersion = verifiedMinorVersions[\n      currentMinorNodeId\n    ];\n\n    VerifiedMinorVersion memory prevVersion;\n    while (nextVersion.versionNumber < targetVersion.minorVersion) {\n      prevMinorNodeId = currentMinorNodeId;\n      prevVersion = nextVersion;\n      currentMinorNodeId = nextVersion.nextMinorNodeId;\n      nextVersion = verifiedMinorVersions[currentMinorNodeId];\n    }\n\n    string memory prevPackageLocation;\n    if (prevVersion.patchNodeId != 0x0) {\n      prevPackageLocation = proposedVersions[prevVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    string memory nextPackageLocation;\n    if (nextVersion.patchNodeId != 0x0) {\n      nextPackageLocation = proposedVersions[nextVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    return (\n      prevMinorNodeId,\n      prevPackageLocation,\n      nextMinorNodeId,\n      nextPackageLocation\n    );\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/OwnershipBridgeLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../PackageOwnershipManager.sol\";\nimport \"./ITokenBridge.sol\";\nimport \"../interfaces/IOwnershipBridgeLink.sol\";\n\ncontract OwnershipBridgeLink is IOwnershipBridgeLink, OwnableUpgradeable {\n  address public bridge;\n  address public bridgeLink;\n  address public packageOwnershipManager;\n  bytes32 public blockchainName;\n  bytes32 public bridgeChainId;\n  uint256 public relayOwnershipGasLimit;\n\n  constructor(\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  ) {\n    initialize(\n      _bridge,\n      _packageOwnershipManager,\n      _blockchainName,\n      _bridgeChainId,\n      _relayOwnershipGasLimit\n    );\n  }\n\n  function initialize(\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  ) public initializer {\n    __Ownable_init();\n\n    bridge = _bridge;\n    packageOwnershipManager = _packageOwnershipManager;\n    blockchainName = _blockchainName;\n    bridgeChainId = _bridgeChainId;\n    relayOwnershipGasLimit = _relayOwnershipGasLimit;\n  }\n\n  function updateBridge(address _bridge) public onlyOwner {\n    bridge = _bridge;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updatePackageOwnershipManager(address _packageOwnershipManager)\n    public\n    onlyOwner\n  {\n    packageOwnershipManager = _packageOwnershipManager;\n  }\n\n  function updateBlockchainName(bytes32 _blockchainName) public onlyOwner {\n    blockchainName = _blockchainName;\n  }\n\n  function updateBridgeChainId(bytes32 _bridgeChainId) public onlyOwner {\n    bridgeChainId = _bridgeChainId;\n  }\n\n  function updateRelayOwnershipGasLimit(uint256 _relayOwnershipGasLimit)\n    public\n    onlyOwner\n  {\n    relayOwnershipGasLimit = _relayOwnershipGasLimit;\n  }\n\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == packageOwnershipManager);\n\n    bytes4 methodSelector = IOwnershipBridgeLink(address(0))\n      .receiveOwnership\n      .selector;\n    bytes memory data = abi.encodeWithSelector(\n      methodSelector,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n    ITokenBridge(bridge).requireToPassMessage(\n      bridgeLink,\n      data,\n      relayOwnershipGasLimit\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == bridge);\n\n    ITokenBridge bridgeContract = ITokenBridge(bridge);\n    assert(bridgeContract.messageSender() == bridgeLink);\n    assert(bridgeContract.messageSourceChainId() == bridgeChainId);\n\n    PackageOwnershipManager(packageOwnershipManager).receiveOwnership(\n      blockchainName,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/mocks/VerificationRootBridgeLinkMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../../VersionVerificationManager.sol\";\nimport \"../../../PackageOwnershipManager.sol\";\nimport \"../ITokenBridge.sol\";\nimport \"../VerificationRootBridgeLink.sol\";\nimport \"../../interfaces/IVerificationRootBridgeLink.sol\";\n\ncontract VerificationRootBridgeLinkMock is VerificationRootBridgeLink {\n  constructor(\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  )\n    VerificationRootBridgeLink(\n      _bridge,\n      _bridgeChainId,\n      _relayVerificationRootGasLimit\n    )\n  {}\n\n  function relayVerificationRoot(bytes32 verificationRoot) public override {\n    assert(msg.sender == verificationRootRelayer);\n\n    IVerificationRootBridgeLink(bridgeLink).receiveVerificationRoot(\n      verificationRoot\n    );\n  }\n\n  function receiveVerificationRoot(bytes32 verificationRoot) public override {\n    assert(msg.sender == bridgeLink);\n\n    VersionVerificationManager(versionVerificationManager)\n      .updateVerificationRoot(verificationRoot);\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/mocks/OwnershipBridgeLinkMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../../PackageOwnershipManager.sol\";\nimport \"../ITokenBridge.sol\";\nimport \"../OwnershipBridgeLink.sol\";\n\ncontract OwnershipBridgeLinkMock is OwnershipBridgeLink {\n  constructor(\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  )\n    OwnershipBridgeLink(\n      _bridge,\n      _packageOwnershipManager,\n      _blockchainName,\n      _bridgeChainId,\n      _relayOwnershipGasLimit\n    )\n  {}\n\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == packageOwnershipManager);\n\n    OwnershipBridgeLink(bridgeLink).receiveOwnership(\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == bridgeLink);\n\n    PackageOwnershipManager(packageOwnershipManager).receiveOwnership(\n      blockchainName,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n}\n"
    },
    "contracts/versioning/registrar/PolywrapRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registrar.sol\";\n\ncontract PolywrapRegistrar is Registrar {\n  constructor(address _registry) Registrar(_registry) {}\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/DNSResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\n    ENS ens;\n\n    /**\n     * A mapping of authorisations. An address that is authorised for a name\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (node, owner, caller) => isAuthorised\n     */\n    mapping(bytes32=>mapping(address=>mapping(address=>bool))) public authorisations;\n\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\n\n    constructor(ENS _ens) {\n        ens = _ens;\n    }\n\n    /**\n     * @dev Sets or clears an authorisation.\n     * Authorisations are specific to the caller. Any account can set an authorisation\n     * for any name, but the authorisation that is checked will be that of the\n     * current owner of a name. Thus, transferring a name effectively clears any\n     * existing authorisations, and new authorisations can be set in advance of\n     * an ownership transfer if desired.\n     *\n     * @param node The name to change the authorisation on.\n     * @param target The address that is to be authorised or deauthorised.\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\n     */\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\n        authorisations[node][msg.sender][target] = isAuthorised;\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\n    }\n\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\n        address owner = ens.owner(node);\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\n    }\n\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\n        results = new bytes[](data.length);\n        for(uint i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override(ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) public pure returns(bool) {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract ABIResolver is ResolverBase {\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\n\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        abis[node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\n        mapping(uint256=>bytes) storage abiset = abis[node];\n\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract AddrResolver is ResolverBase {\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\n    bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06;\n    uint constant private COIN_TYPE_ETH = 60;\n\n    event AddrChanged(bytes32 indexed node, address a);\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\n\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(bytes32 node, address a) external authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if(a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if(coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        _addresses[node][coinType] = a;\n    }\n\n    function addr(bytes32 node, uint coinType) public view returns(bytes memory) {\n        return _addresses[node][coinType];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract ContentHashResolver is ResolverBase {\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\n\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    mapping(bytes32=>bytes) hashes;\n\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\n        hashes[node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory) {\n        return hashes[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\nimport \"../../dnssec-oracle/RRUtils.sol\";\n\nabstract contract DNSResolver is ResolverBase {\n    using RRUtils for *;\n    using BytesUtils for bytes;\n\n    bytes4 constant private DNS_RECORD_INTERFACE_ID = 0xa8fa5682;\n    bytes4 constant private DNS_ZONE_INTERFACE_ID = 0x5c47637c;\n\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\n    event DNSZoneCleared(bytes32 indexed node);\n\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\n\n    // Zone hashes for the domains.\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\n    // resource containing a single zonefile.\n    // node => contenthash\n    mapping(bytes32=>bytes) private zonehashes;\n\n    // Version the mapping for each zone.  This allows users who have lost\n    // track of their entries to effectively delete an entire zone by bumping\n    // the version number.\n    // node => version\n    mapping(bytes32=>uint256) private versions;\n\n    // The records themselves.  Stored as binary RRSETs\n    // node => version => name => resource => data\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>mapping(uint16=>bytes)))) private records;\n\n    // Count of number of entries for a given name.  Required for DNS resolvers\n    // when resolving wildcards.\n    // node => version => name => number of records\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>uint16))) private nameEntriesCount;\n\n    /**\n     * Set one or more DNS records.  Records are supplied in wire-format.\n     * Records with the same node/name/resource must be supplied one after the\n     * other to ensure the data is updated correctly. For example, if the data\n     * was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     a.example.com IN A 5.6.7.8\n     *     www.example.com IN CNAME a.example.com.\n     * then this would store the two A records for a.example.com correctly as a\n     * single RRSET, however if the data was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     www.example.com IN CNAME a.example.com.\n     *     a.example.com IN A 5.6.7.8\n     * then this would store the first A record, the CNAME, then the second A\n     * record which would overwrite the first.\n     *\n     * @param node the namehash of the node for which to set the records\n     * @param data the DNS wire format records to set\n     */\n    function setDNSRecords(bytes32 node, bytes calldata data) external authorised(node) {\n        uint16 resource = 0;\n        uint256 offset = 0;\n        bytes memory name;\n        bytes memory value;\n        bytes32 nameHash;\n        // Iterate over the data to add the resource records\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\n            if (resource == 0) {\n                resource = iter.dnstype;\n                name = iter.name();\n                nameHash = keccak256(abi.encodePacked(name));\n                value = bytes(iter.rdata());\n            } else {\n                bytes memory newName = iter.name();\n                if (resource != iter.dnstype || !name.equals(newName)) {\n                    setDNSRRSet(node, name, resource, data, offset, iter.offset - offset, value.length == 0);\n                    resource = iter.dnstype;\n                    offset = iter.offset;\n                    name = newName;\n                    nameHash = keccak256(name);\n                    value = bytes(iter.rdata());\n                }\n            }\n        }\n        if (name.length > 0) {\n            setDNSRRSet(node, name, resource, data, offset, data.length - offset, value.length == 0);\n        }\n    }\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) public view returns (bytes memory) {\n        return records[node][versions[node]][name][resource];\n    }\n\n    /**\n     * Check if a given node has records.\n     * @param node the namehash of the node for which to check the records\n     * @param name the namehash of the node for which to check the records\n     */\n    function hasDNSRecords(bytes32 node, bytes32 name) public view returns (bool) {\n        return (nameEntriesCount[node][versions[node]][name] != 0);\n    }\n\n    /**\n     * Clear all information for a DNS zone.\n     * @param node the namehash of the node for which to clear the zone\n     */\n    function clearDNSZone(bytes32 node) public authorised(node) {\n        versions[node]++;\n        emit DNSZoneCleared(node);\n    }\n\n    /**\n     * setZonehash sets the hash for the zone.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The zonehash to set\n     */\n    function setZonehash(bytes32 node, bytes calldata hash) external authorised(node) {\n        bytes memory oldhash = zonehashes[node];\n        zonehashes[node] = hash;\n        emit DNSZonehashChanged(node, oldhash, hash);\n    }\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory) {\n        return zonehashes[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == DNS_RECORD_INTERFACE_ID ||\n               interfaceID == DNS_ZONE_INTERFACE_ID ||\n               super.supportsInterface(interfaceID);\n    }\n\n    function setDNSRRSet(\n        bytes32 node,\n        bytes memory name,\n        uint16 resource,\n        bytes memory data,\n        uint256 offset,\n        uint256 size,\n        bool deleteRecord) private\n    {\n        uint256 version = versions[node];\n        bytes32 nameHash = keccak256(name);\n        bytes memory rrData = data.substring(offset, size);\n        if (deleteRecord) {\n            if (records[node][version][nameHash][resource].length != 0) {\n                nameEntriesCount[node][version][nameHash]--;\n            }\n            delete(records[node][version][nameHash][resource]);\n            emit DNSRecordDeleted(node, name, resource);\n        } else {\n            if (records[node][version][nameHash][resource].length == 0) {\n                nameEntriesCount[node][version][nameHash]++;\n            }\n            records[node][version][nameHash][resource] = rrData;\n            emit DNSRecordChanged(node, name, resource, rrData);\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\nimport \"./AddrResolver.sol\";\n\nabstract contract InterfaceResolver is ResolverBase, AddrResolver {\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\"interfaceImplementer(bytes32,bytes4)\"));\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\n\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\n\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 165 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\n        interfaces[node][interfaceID] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\n        address implementer = interfaces[node][interfaceID];\n        if(implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if(a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", INTERFACE_META_ID));\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override(AddrResolver, ResolverBase) public pure returns(bool) {\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract NameResolver is ResolverBase {\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\n\n    event NameChanged(bytes32 indexed node, string name);\n\n    mapping(bytes32=>string) names;\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param name The name to set.\n     */\n    function setName(bytes32 node, string calldata name) external authorised(node) {\n        names[node] = name;\n        emit NameChanged(node, name);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory) {\n        return names[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract PubkeyResolver is ResolverBase {\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\n\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(bytes32=>PublicKey) pubkeys;\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\n        pubkeys[node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\n        return (pubkeys[node].x, pubkeys[node].y);\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol": {
      "content": "pragma solidity >=0.8.4;\nimport \"../ResolverBase.sol\";\n\nabstract contract TextResolver is ResolverBase {\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\n\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n\n    mapping(bytes32=>mapping(string=>string)) texts;\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\n        texts[node][key] = value;\n        emit TextChanged(node, key, key);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\n        return texts[node][key];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol": {
      "content": "pragma solidity >=0.8.4;\nabstract contract ResolverBase {\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n\n    function supportsInterface(bytes4 interfaceID) virtual public pure returns(bool) {\n        return interfaceID == INTERFACE_META_ID;\n    }\n\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/dnssec-oracle/RRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n*/\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return The length of the DNS name at 'offset', in bytes.\n    */\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\n        uint idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n    * @dev Returns a DNS format name at the specified offset of self.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return ret The name.\n    */\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\n        uint len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return The number of labels in the DNS name at 'offset', in bytes.\n    */\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\n        uint count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint constant RRSIG_TYPE = 0;\n    uint constant RRSIG_ALGORITHM = 2;\n    uint constant RRSIG_LABELS = 3;\n    uint constant RRSIG_TTL = 4;\n    uint constant RRSIG_EXPIRATION = 8;\n    uint constant RRSIG_INCEPTION = 12;\n    uint constant RRSIG_KEY_TAG = 16;\n    uint constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\n    }\n\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n    * @dev An iterator over resource records.\n    */\n    struct RRIterator {\n        bytes data;\n        uint offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint rdataOffset;\n        uint nextOffset;\n    }\n\n    /**\n    * @dev Begins iterating over resource records.\n    * @param self The byte string to read from.\n    * @param offset The offset to start reading at.\n    * @return ret An iterator object.\n    */\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n    * @dev Returns true iff there are more RRs to iterate.\n    * @param iter The iterator to check.\n    * @return True iff the iterator has finished.\n    */\n    function done(RRIterator memory iter) internal pure returns(bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n    * @dev Moves the iterator to the next resource record.\n    * @param iter The iterator to advance.\n    */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n    * @dev Returns the name of the current record.\n    * @param iter The iterator.\n    * @return A new bytes object containing the owner name from the RR.\n    */\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\n    }\n\n    /**\n    * @dev Returns the rdata portion of the current record.\n    * @param iter The iterator.\n    * @return A new bytes object containing the RR's RDATA.\n    */\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\n    }\n\n    uint constant DNSKEY_FLAGS = 0;\n    uint constant DNSKEY_PROTOCOL = 2;\n    uint constant DNSKEY_ALGORITHM = 3;\n    uint constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\n    } \n\n    uint constant DS_KEY_TAG = 0;\n    uint constant DS_ALGORITHM = 2;\n    uint constant DS_DIGEST_TYPE = 3;\n    uint constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    struct NSEC3 {\n        uint8 hashAlgorithm;\n        uint8 flags;\n        uint16 iterations;\n        bytes salt;\n        bytes32 nextHashedOwnerName;\n        bytes typeBitmap;\n    }\n\n    uint constant NSEC3_HASH_ALGORITHM = 0;\n    uint constant NSEC3_FLAGS = 1;\n    uint constant NSEC3_ITERATIONS = 2;\n    uint constant NSEC3_SALT_LENGTH = 4;\n    uint constant NSEC3_SALT = 5;\n\n    function readNSEC3(bytes memory data, uint offset, uint length) internal pure returns(NSEC3 memory self) {\n        uint end = offset + length;\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\n        offset = offset + NSEC3_SALT;\n        self.salt = data.substring(offset, saltLength);\n        offset += saltLength;\n        uint8 nextLength = data.readUint8(offset);\n        require(nextLength <= 32);\n        offset += 1;\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\n        offset += nextLength;\n        self.typeBitmap = data.substring(offset, end - offset);\n    }\n\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype) internal pure returns(bool) {\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\n    }\n\n    /**\n    * @dev Checks if a given RR type exists in a type bitmap.\n    * @param bitmap The byte string to read the type bitmap from.\n    * @param offset The offset to start reading at.\n    * @param rrtype The RR type to check for.\n    * @return True if the type is found in the bitmap, false otherwise.\n    */\n    function checkTypeBitmap(bytes memory bitmap, uint offset, uint16 rrtype) internal pure returns (bool) {\n        uint8 typeWindow = uint8(rrtype >> 8);\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\n        for (uint off = offset; off < bitmap.length;) {\n            uint8 window = bitmap.readUint8(off);\n            uint8 len = bitmap.readUint8(off + 1);\n            if (typeWindow < window) {\n                // We've gone past our window; it's not here.\n                return false;\n            } else if (typeWindow == window) {\n                // Check this type bitmap\n                if (len <= windowByte) {\n                    // Our type is past the end of the bitmap\n                    return false;\n                }\n                return (bitmap.readUint8(off + windowByte + 2) & windowBitmask) != 0;\n            } else {\n                // Skip this type bitmap\n                off += len + 2;\n            }\n        }\n\n        return false;\n    }\n\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint off;\n        uint otheroff;\n        uint prevoff;\n        uint otherprevoff;\n        uint counts = labelCount(self, 0);\n        uint othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if(otheroff == 0) {\n            return 1;\n        }\n\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\n        return int32(i1) - int32(i2) >= 0;\n    }\n\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\n        return off + 1 + body.readUint8(off);\n    }\n}"
    },
    "@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n        uint shortest = len;\n        if (otherlen < len)\n        shortest = otherlen;\n\n        uint selfptr;\n        uint otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                int diff = int(a & mask) - int(b & mask);\n                if (diff != 0)\n                return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int(len) - int(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)),  mask)\n        }\n    }\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint dest;\n        uint src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\n        require(len <= 52);\n\n        uint ret = 0;\n        uint8 decoded;\n        for(uint i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if(i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint bitlen = len * 5;\n        if(len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if(len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if(len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if(len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if(len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n}"
    },
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The start offset to write to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write the byte at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (right-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "contracts/ens/TestPublicResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\";\n\ncontract TestPublicResolver is PublicResolver {\n  constructor(ENS _ens) PublicResolver(_ens) {}\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/ethregistrar/BaseRegistrar.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract BaseRegistrar is Ownable, IERC721 {\n    uint constant public GRACE_PERIOD = 90 days;\n\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n    event NameRenewed(uint256 indexed id, uint expires);\n\n    // The ENS registry\n    ENS public ens;\n\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address=>bool) public controllers;\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) virtual external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) virtual external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) virtual external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) virtual external view returns(uint);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) virtual public view returns(bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(uint256 id, address owner, uint duration) virtual external returns(uint);\n\n    function renew(uint256 id, uint duration) virtual external returns(uint);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) virtual external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/ethregistrar/BaseRegistrarImplementation.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"./BaseRegistrar.sol\";\ncontract BaseRegistrarImplementation is ERC721, BaseRegistrar  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}\n"
    },
    "contracts/ens/TestEthRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/ens-contracts/contracts/ethregistrar/BaseRegistrarImplementation.sol\";\n\ncontract TestEthRegistrar is BaseRegistrarImplementation {\n  constructor(ENS _ens, bytes32 _baseNode)\n    public\n    BaseRegistrarImplementation(_ens, _baseNode)\n  {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}